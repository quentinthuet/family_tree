-- Programme de test du module Registre
-- On ne teste pas les fonctions qui sont identiques dans Registre et
-- Table_De_Hachage

with Ada.Text_IO;       use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Registre;


procedure Test_Registre is

    package M_R is new Registre (3);
    use M_R;



    M_Informations : constant array (1..8) of T_Informations
            := (("aaa","zzz",HOMME,(01,01,1907),"AAA",(01,01,1983)),
                ("ddd","www",FEMME,(01,01,1891),"DDD",(01,01,1983)),
                ("fff","uuu",FEMME,(01,01,1907),"FFF",(01,01,1983)),
                ("ggg","ttt",HOMME,(01,01,1907),"GGG",(01,01,1983)),
                ("bbb","yyy",FEMME,(01,01,1907),"BBB",(01,01,1983)),
                ("ccc","xxx",HOMME,(01,01,1984),"CCC",(01,01,1983)),
                ("eee","vvv",HOMME,(31,06,1950),"EEE",(01,01,1983)),
                ("hhh","sss",FEMME,(19,06,1908),"HHH",(29,02,1983)));

    M_Nouvelles_Informations : constant array (1..5) of T_Informations
            := (("iii","rrr",HOMME,(01,01,1907),"III",(01,01,1983)),
                ("jjj","qqq",FEMME,(01,01,1907),"JJJ",(01,01,1983)),
                ("kkk","ppp",HOMME,(01,01,1907),"KKK",(01,01,1983)),
                ("lll","ooo",FEMME,(01,01,1907),"LLL",(01,01,1983)),
                ("mmm","nnn",FEMME,(01,01,1907),"MMM",(01,01,1983)));

    M_Dates_Naissance_Fils : constant array (1..8) of T_Date
            := ((01,01,1970),(01,01,1970),(01,01,1970), (01,01,1970),
                (01,01,1997),(01,01,1970),(01,01,1970), (01,01,1970));

    procedure Tester_Enregistrer is
        R1 : M_TH.T_TH;
    begin
        M_TH.Initialiser (R1);

        for i in 1..9 loop
            begin
                Enregistrer (R1,
                             ((i-1) mod 8) + 1,
                             M_Informations (((i-1) mod 8) + 1),
                             M_Dates_Naissance_Fils (((i-1) mod 8) + 1));
                pragma Assert (i < 5);
                -- Les informations 5, 6, 7 et 8 sont incohérentes et 9 est clé
                -- présente
                -- On vérifie que ce qui suit Enregistrer dans la boucle n'est pas
                -- exécuté pour i = 5..9 (et donc que les exceptions sont bien
                -- levées)
            exception
                when Date_Fils_Incoherente_Exception =>
                    pragma Assert (i = 5);
                when Ordre_Date_Incoherent_Exception =>
                    pragma Assert (i = 6);
                when Date_Naissance_Impossible_Exception =>
                    pragma Assert (i = 7);
                when Date_Deces_Impossible_Exception =>
                    pragma Assert (i = 8);
                when Cle_Presente_Exception =>
                    pragma Assert (i = 9);
            end;
        end loop;
        pragma Assert (M_TH.Taille (R1) = 4);
        for i in 1..4 loop
            pragma Assert (M_TH.Element (R1, i) = M_Informations (i));
        end loop;
        M_TH.Vider (R1);
    end Tester_Enregistrer;

    procedure Tester_Modifier is
        R1 : M_TH.T_TH;
    begin
        M_TH.Initialiser (R1);

        for i in 1..4 loop
            Enregistrer (R1, i, M_Informations (i), M_Dates_Naissance_Fils (i));
        end loop;
        for i in 1..5 loop
            begin
                Modifier (R1, i, M_Nouvelles_Informations (i), M_Dates_Naissance_Fils (((i-1) mod 4) + 1));
                pragma Assert (i /= 5);
                -- On vérifie que ce qui suit Modifier n'est jamais exécuté
                -- (et donc que l'exception est bien levée)
            exception
                when Cle_Absente_Exception =>
                    pragma Assert (i = 5);
            end;
        end loop;
        pragma Assert (M_TH.Taille (R1) = 4);
        for i in 1..4 loop
            pragma Assert (M_TH.Element (R1, i) = M_Nouvelles_Informations (i));
        end loop;
        for i in 1..4 loop
            begin
                Modifier (R1, i, M_Informations (i + 4), M_Dates_Naissance_Fils (i + 4));
                pragma Assert (False);
                -- On vérifie que ce qui suit Modifier n'est jamais exécuté
                -- (et donc que les exceptions sont bien levées)
            exception
                when Date_Fils_Incoherente_Exception
                    => pragma Assert (i = 1);
                when Ordre_Date_Incoherent_Exception
                    => pragma Assert (i = 2);
                when Date_Naissance_Impossible_Exception
                    => pragma Assert (i = 3);
                when Date_Deces_Impossible_Exception
                    => pragma Assert (i = 4);
            end;
        end loop;
        pragma Assert (M_TH.Taille (R1) = 4);
        for i in 1..4 loop
            pragma Assert (M_TH.Element (R1, i) = M_Nouvelles_Informations (i));
        end loop;
        M_TH.Vider (R1);
    end Tester_Modifier;


begin
    Tester_Enregistrer;
    Tester_Modifier;
end Test_Registre;
